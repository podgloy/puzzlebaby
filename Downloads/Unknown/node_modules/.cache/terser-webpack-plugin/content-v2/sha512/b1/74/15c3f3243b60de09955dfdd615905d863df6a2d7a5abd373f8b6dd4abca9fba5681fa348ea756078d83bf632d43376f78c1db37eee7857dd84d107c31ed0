{"map":"{\"version\":3,\"sources\":[\"/Users/godploy/Downloads/Unknown/src/App.js\",\"/Users/godploy/Downloads/Unknown/src/index.js\"],\"names\":[\"NUM_ROWS\",\"NUM_COLS\",\"boardImage\",\"App\",\"boardRef\",\"useRef\",\"pieces\",\"setPieces\",\"useState\",\"targets\",\"setTargets\",\"completed\",\"setCompleted\",\"useEffect\",\"current\",\"rect\",\"getBoundingClientRect\",\"newTargets\",\"Array\",\"from\",\"length\",\"_\",\"index\",\"id\",\"targetX\",\"width\",\"targetY\",\"Math\",\"floor\",\"height\",\"newPieces\",\"map\",\"target\",\"_objectSpread\",\"initialX\",\"left\",\"random\",\"initialY\",\"top\",\"image\",\"concat\",\"React\",\"createElement\",\"className\",\"ref\",\"src\",\"alt\",\"piece\",\"motion\",\"div\",\"key\",\"style\",\"position\",\"cursor\",\"drag\",\"includes\",\"dragElastic\",\"initial\",\"x\",\"y\",\"animate\",\"onDragEnd\",\"event\",\"info\",\"handleDragEnd\",\"find\",\"t\",\"abs\",\"point\",\"prev\",\"p\",\"objectFit\",\"rootElement\",\"document\",\"getElementById\",\"ReactDOM\",\"render\",\"StrictMode\"],\"mappings\":\"6KAuNA,MAAMA,EAAW,EACXC,EAAW,EACXC,EAAa,qBAEJ,SAASC,IACtB,MAAMC,EAAWC,OAAAA,EAAAA,OAAAA,CAAO,OACjBC,EAAQC,GAAaC,OAAAA,EAAAA,SAAAA,CAAS,KAC9BC,EAASC,GAAcF,OAAAA,EAAAA,SAAAA,CAAS,KAChCG,EAAWC,GAAgBJ,OAAAA,EAAAA,SAAAA,CAAS,IAE3CK,OAAAA,EAAAA,UAAAA,CAAU,KACR,GAAIT,EAASU,QAAS,CACpB,MAAMC,EAAOX,EAASU,QAAQE,wBAGxBC,EAAaC,MAAMC,KAAK,CAAEC,OAAQpB,EAAWC,GAAY,CAACoB,EAAGC,KAAK,CACtEC,GAAID,EACJE,QAAUF,EAAQrB,GAAac,EAAKU,MAAQxB,GAC5CyB,QAASC,KAAKC,MAAMN,EAAQrB,IAAac,EAAKc,OAAS7B,MAInD8B,EAAYb,EAAWc,IAAI,CAACC,EAAQV,IAAKW,OAAAA,EAAAA,EAAAA,CAAAA,OAAAA,EAAAA,EAAAA,CAAA,GAC1CD,GAAM,GAAA,CACTE,SAAUnB,EAAKoB,KAAO,IAAsB,GAAhBR,KAAKS,SACjCC,SAAUtB,EAAKuB,IAAMX,KAAKS,SAAWrB,EAAKc,OAC1CU,MAAK,oBAAAC,OAAsBlB,EAAQ,EAAC,QACpCG,MAAOV,EAAKU,MAAQxB,EACpB4B,OAAQd,EAAKc,OAAS7B,KAGxBU,EAAWO,GACXV,EAAUuB,KAEX,IAgBH,OACEW,EAAAA,EAAAC,cAAA,MAAA,CAAKC,UAAU,aACbF,EAAAA,EAAAC,cAAA,MAAA,CAAKC,UAAU,mBAEbF,EAAAA,EAAAC,cAAA,MAAA,CAAKC,UAAU,QAAQC,IAAKxC,GAC1BqC,EAAAA,EAAAC,cAAA,MAAA,CAAKG,IAAK3C,EAAY4C,IAAI,eAAeH,UAAU,iBAIpDrC,EAAOyB,IAAKgB,GACXN,EAAAA,EAAAC,cAACM,EAAAA,EAAOC,IAAG,CACTC,IAAKH,EAAMxB,GACXoB,UAAU,QACVQ,MAAO,CACL1B,MAAOsB,EAAMtB,MACbI,OAAQkB,EAAMlB,OACduB,SAAU,WACVC,OAAQ,QAEVC,MAAO3C,EAAU4C,SAASR,EAAMxB,IAChCiC,YAAa,GACbC,QAAS,CAAEC,EAAGX,EAAMb,SAAUyB,EAAGZ,EAAMV,UACvCuB,QAAS,CAAEF,EAAGX,EAAMb,SAAUyB,EAAGZ,EAAMV,UACvCwB,UAAWA,CAACC,EAAOC,IArCPC,EAACF,EAAOC,EAAMhB,KAClC,MAAMf,EAASvB,EAAQwD,KAAMC,GAAMA,EAAE3C,KAAOwB,EAAMxB,IAGhDI,KAAKwC,IAAIJ,EAAKK,MAAMV,EAAI1B,EAAOR,SAAWuB,EAAMtB,MAAQ,GACxDE,KAAKwC,IAAIJ,EAAKK,MAAMT,EAAI3B,EAAON,SAAWqB,EAAMlB,OAAS,IAEzDjB,EAAcyD,GAAS,IAAIA,EAAMtB,EAAMxB,KACvChB,EAAW8D,GACTA,EAAKtC,IAAKuC,GAAOA,EAAE/C,KAAOwB,EAAMxB,GAAEU,OAAAA,EAAAA,EAAAA,CAAAA,OAAAA,EAAAA,EAAAA,CAAA,GAAQqC,GAAC,GAAA,CAAEpC,SAAUF,EAAOR,QAASa,SAAUL,EAAON,UAAY4C,MA4BpEN,CAAcF,EAAOC,EAAMhB,IAEvDN,EAAAA,EAAAC,cAAA,MAAA,CACEG,IAAKE,EAAMR,MACXO,IAAG,SAAAN,OAAWO,EAAMxB,IACpB4B,MAAO,CACL1B,MAAO,OACPI,OAAQ,OACR0C,UAAW,iBCnS3B,MAAMC,EAAcC,SAASC,eAAe,QAC5CC,EAAAA,EAASC,OACPnC,EAAAA,EAAAC,cAACD,EAAAA,EAAMoC,WAAU,KACfpC,EAAAA,EAAAC,cAACvC,EAAG,OAENqE\",\"sourcesContent\":[\"// import React, { useState } from \\\"react\\\";\\n// import { motion } from \\\"framer-motion\\\";\\n// import \\\"./styles.css\\\";\\n\\n// const NUM_ROWS = 4;\\n// const NUM_COLS = 3;\\n// const PIECE_SIZE = 80; // ขนาดชิ้นจิ๊กซอว์ที่เล็กลง\\n\\n// const OFFSET_X = 200; // ขยับตำแหน่งแนวนอน\\n// const OFFSET_Y = 100; // ขยับตำแหน่งแนวตั้ง\\n\\n// const createGrid = () =>\\n//   Array.from({ length: NUM_ROWS * NUM_COLS }, (_, index) => ({\\n//     id: index,\\n//     targetX: (index % NUM_COLS) * 100 + OFFSET_X, // 🔥 ขยับกรอบเป้าหมาย\\n//     targetY: Math.floor(index / NUM_COLS) * 100 + OFFSET_Y, // 🔥 ขยับกรอบเป้าหมาย\\n//     initialX: 500 + Math.random() * 50, // 🔥 จุดเริ่มต้นของจิ๊กซอว์\\n//     initialY: 300 + Math.random() * 50,\\n//     image: `/img/puzzle/piece${index + 1}.png`, \\n//   }));\\n\\n\\n// export default function App() {\\n//   const [pieces, setPieces] = useState(createGrid());\\n\\n//   const handleDragEnd = (event, info, piece) => {\\n//     const target = pieces.find((p) => p.id === piece.id);\\n\\n//     console.log(`🟢 Piece ${piece.id} Dragged to:`, {\\n//       draggedX: info.point.x,\\n//       draggedY: info.point.y,\\n//       targetX: target.targetX,\\n//       targetY: target.targetY,\\n//     });\\n\\n//     if (\\n//       Math.abs(info.point.x - target.targetX) < PIECE_SIZE * 0.75 &&\\n//       Math.abs(info.point.y - target.targetY) < PIECE_SIZE * 0.75\\n//     )\\n//      {\\n//       setPieces((prev) =>\\n//         prev.map((p) =>\\n//           p.id === piece.id\\n//             ? { ...p, initialX: target.targetX, initialY: target.targetY, locked: true }\\n//             : p\\n//         )\\n//       );\\n//     }\\n//   };\\n\\n//   return (\\n//     <div className=\\\"board\\\" style={{ position: \\\"relative\\\", width: \\\"100vw\\\", height: \\\"100vh\\\" }}>\\n//       {/* กรอบเป้าหมาย */}\\n//       {pieces.map((piece) => (\\n//         <div\\n//           key={`target-${piece.id}`}\\n//           className=\\\"target\\\"\\n//           style={{\\n//             left: piece.targetX,\\n//             top: piece.targetY,\\n//             width: PIECE_SIZE,\\n//             height: PIECE_SIZE,\\n//             position: \\\"absolute\\\",\\n//             border: \\\"2px dashed #ccc\\\",\\n//           }}\\n//         />\\n//       ))}\\n\\n//       {/* ชิ้นจิ๊กซอว์ */}\\n//       {pieces.map((piece) => (\\n//         <motion.div\\n//           key={`piece-${piece.id}`}\\n//           className=\\\"piece\\\"\\n//           style={{\\n//             position: \\\"absolute\\\",\\n//             cursor: piece.locked ? \\\"default\\\" : \\\"grab\\\",\\n//           }}\\n//           drag={!piece.locked} // ✅ ล็อคชิ้นส่วนถ้าลากไปวางแล้ว\\n//           dragElastic={0.5}\\n//           initial={{ x: piece.initialX, y: piece.initialY }}\\n//           animate={{ x: piece.initialX, y: piece.initialY }} // ✅ ใช้ค่าที่อัปเดตล่าสุด\\n//           onPointerDown={(event) => event.preventDefault()} // ป้องกัน Safari ลากรูปออก\\n//           onDragStart={(event) => event.preventDefault()} // ป้องกันการดึงรูปออกจากเว็บ\\n//           onDragEnd={(event, info) => handleDragEnd(event, info, piece)}\\n//         >\\n//           <img\\n//             src={piece.image}\\n//             alt={`piece-${piece.id}`}\\n//             style={{\\n//               width: `${PIECE_SIZE}px`, // ✅ กำหนดขนาดเป็นสัดส่วน\\n//               height: `${PIECE_SIZE}px`,\\n//               objectFit: \\\"contain\\\",\\n//             }}\\n//           />\\n//         </motion.div>\\n//       ))}\\n//     </div>\\n//   );\\n// }\\n\\n// 2\\n\\n// import React, { useState, useEffect, useRef } from \\\"react\\\";\\n// import { motion } from \\\"framer-motion\\\";\\n// import \\\"./styles.css\\\";\\n\\n// const NUM_ROWS = 4;\\n// const NUM_COLS = 3;\\n// const boardImage = \\\"/img/puzzleboard.png\\\";\\n\\n// export default function App() {\\n//   const boardRef = useRef(null);\\n//   const [pieces, setPieces] = useState([]);\\n//   const [targets, setTargets] = useState([]);\\n//   const [completed, setCompleted] = useState([]);\\n\\n//   useEffect(() => {\\n//     if (boardRef.current) {\\n//       const rect = boardRef.current.getBoundingClientRect();\\n\\n//       // ✅ คำนวณตำแหน่งของเป้าหมายบนกระดาน\\n//       const newTargets = Array.from({ length: NUM_ROWS * NUM_COLS }, (_, index) => ({\\n//         id: index,\\n//         targetX: (index % NUM_COLS) * (rect.width / NUM_COLS),\\n//         targetY: Math.floor(index / NUM_COLS) * (rect.height / NUM_ROWS),\\n//       }));\\n\\n//       // ✅ กระจายชิ้นส่วนอยู่ด้านซ้ายของกระดาน\\n//       const newPieces = newTargets.map((target, index) => ({\\n//         ...target,\\n//         initialX: rect.left - 200 + (index % 2) * 50, // 🔥 ปรับให้อยู่ฝั่งซ้าย\\n//         initialY: rect.top + Math.random() * (rect.height - 100),\\n//         image: `/img/puzzle/piece${target.id + 1}.png`,\\n//         width: rect.width / NUM_COLS,\\n//         height: rect.height / NUM_ROWS,\\n//       }));\\n\\n//       setTargets(newTargets);\\n//       setPieces(newPieces);\\n//     }\\n//   }, []);\\n\\n//   const handleDragEnd = (event, info, piece) => {\\n//     const target = targets.find((t) => t.id === piece.id);\\n\\n//     if (\\n//       Math.abs(info.point.x - target.targetX) < piece.width / 2 &&\\n//       Math.abs(info.point.y - target.targetY) < piece.height / 2\\n//     ) {\\n//       setCompleted((prev) => [...prev, piece.id]);\\n//       setPieces((prev) =>\\n//         prev.map((p) =>\\n//           p.id === piece.id ? { ...p, initialX: target.targetX, initialY: target.targetY } : p\\n//         )\\n//       );\\n//     }\\n//   };\\n\\n//   return (\\n//     <div className=\\\"container\\\">\\n//       <div \\n//   className=\\\"board\\\" \\n//   ref={boardRef}\\n//   style={{\\n//     backgroundImage: `url(${boardImage})`,\\n//     backgroundSize: \\\"contain\\\",\\n//     backgroundPosition: \\\"center\\\",\\n//     backgroundRepeat: \\\"no-repeat\\\",\\n//     width: \\\"600px\\\", // กำหนดขนาดให้กระดาน\\n//     height: \\\"800px\\\"\\n//   }}\\n// > \\n// </div>\\n\\n\\n//       {pieces.map((piece) => (\\n//         <motion.div\\n//           key={piece.id}\\n//           className=\\\"piece\\\"\\n//           style={{\\n//             position: \\\"absolute\\\",\\n//             cursor: \\\"grab\\\",\\n//             width: piece.width,\\n//             height: piece.height,\\n//             zIndex: 10, // ✅ ให้ชิ้นส่วนอยู่ด้านบน\\n//           }}\\n//           drag={!completed.includes(piece.id)}\\n//           dragElastic={0.5}\\n//           initial={{ x: piece.initialX, y: piece.initialY }}\\n//           animate={{ x: piece.initialX, y: piece.initialY }}\\n//           onPointerDown={(event) => event.preventDefault()}\\n//           onDragStart={(event) => event.preventDefault()}\\n//           onDragEnd={(event, info) => handleDragEnd(event, info, piece)}\\n//         >\\n//           <img\\n//             src={piece.image}\\n//             alt={`piece-${piece.id}`}\\n//             style={{\\n//               width: \\\"100%\\\",\\n//               height: \\\"100%\\\",\\n//               objectFit: \\\"contain\\\",\\n//             }}\\n//           />\\n//         </motion.div>\\n//       ))}\\n//     </div>\\n//   );\\n// }\\n\\n// 3\\n\\nimport React, { useState, useEffect, useRef } from \\\"react\\\";\\nimport { motion } from \\\"framer-motion\\\";\\nimport \\\"./styles.css\\\";\\n\\nconst NUM_ROWS = 4;\\nconst NUM_COLS = 3;\\nconst boardImage = \\\"/img/artboard6.png\\\"; // ✅ เปลี่ยนเป็น Path รูปของกระดานจริง\\n\\nexport default function App() {\\n  const boardRef = useRef(null);\\n  const [pieces, setPieces] = useState([]);\\n  const [targets, setTargets] = useState([]);\\n  const [completed, setCompleted] = useState([]);\\n\\n  useEffect(() => {\\n    if (boardRef.current) {\\n      const rect = boardRef.current.getBoundingClientRect();\\n\\n      // ✅ สร้างตำแหน่งของเป้าหมาย (Target Grid)\\n      const newTargets = Array.from({ length: NUM_ROWS * NUM_COLS }, (_, index) => ({\\n        id: index,\\n        targetX: (index % NUM_COLS) * (rect.width / NUM_COLS),\\n        targetY: Math.floor(index / NUM_COLS) * (rect.height / NUM_ROWS),\\n      }));\\n\\n      // ✅ สร้างชิ้นจิ๊กซอว์ให้อยู่ฝั่งซ้าย\\n      const newPieces = newTargets.map((target, index) => ({\\n        ...target,\\n        initialX: rect.left - 200 + Math.random() * 50, // กระจายฝั่งซ้าย\\n        initialY: rect.top + Math.random() * rect.height,\\n        image: `/img/puzzle/piece${index + 1}.png`, // ✅ ใส่ path รูปที่ถูกต้อง\\n        width: rect.width / NUM_COLS,\\n        height: rect.height / NUM_ROWS,\\n      }));\\n\\n      setTargets(newTargets);\\n      setPieces(newPieces);\\n    }\\n  }, []);\\n\\n  const handleDragEnd = (event, info, piece) => {\\n    const target = targets.find((t) => t.id === piece.id);\\n\\n    if (\\n      Math.abs(info.point.x - target.targetX) < piece.width / 3 &&\\n      Math.abs(info.point.y - target.targetY) < piece.height / 3\\n    ) {\\n      setCompleted((prev) => [...prev, piece.id]);\\n      setPieces((prev) =>\\n        prev.map((p) => (p.id === piece.id ? { ...p, initialX: target.targetX, initialY: target.targetY } : p))\\n      );\\n    }\\n  };\\n\\n  return (\\n    <div className=\\\"container\\\">\\n      <div className=\\\"board-container\\\">\\n        {/* ✅ กระดานจิ๊กซอว์ */}\\n        <div className=\\\"board\\\" ref={boardRef}>\\n          <img src={boardImage} alt=\\\"Puzzle Board\\\" className=\\\"board-image\\\" />\\n        </div>\\n\\n        {/* ✅ ชิ้นจิ๊กซอว์ */}\\n        {pieces.map((piece) => (\\n          <motion.div\\n            key={piece.id}\\n            className=\\\"piece\\\"\\n            style={{\\n              width: piece.width,\\n              height: piece.height,\\n              position: \\\"absolute\\\",\\n              cursor: \\\"grab\\\",\\n            }}\\n            drag={!completed.includes(piece.id)}\\n            dragElastic={0.5}\\n            initial={{ x: piece.initialX, y: piece.initialY }}\\n            animate={{ x: piece.initialX, y: piece.initialY }}\\n            onDragEnd={(event, info) => handleDragEnd(event, info, piece)}\\n          >\\n            <img\\n              src={piece.image}\\n              alt={`piece-${piece.id}`}\\n              style={{\\n                width: \\\"100%\\\",\\n                height: \\\"100%\\\",\\n                objectFit: \\\"contain\\\",\\n              }}\\n            />\\n          </motion.div>\\n        ))}\\n      </div>\\n    </div>\\n  );\\n}\\n\",\"import React from \\\"react\\\";\\nimport ReactDOM from \\\"react-dom\\\";\\n\\nimport App from \\\"./App\\\";\\n\\nconst rootElement = document.getElementById(\\\"root\\\");\\nReactDOM.render(\\n  <React.StrictMode>\\n    <App />\\n  </React.StrictMode>,\\n  rootElement\\n);\\n\"]}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{11:function(t,e,a){},12:function(t,e,a){\"use strict\";a.r(e);var i=a(0),n=a.n(i),c=a(4),r=a.n(c),o=a(1),l=a(5);a(11);const d=4,s=3,g=\"/img/artboard6.png\";function h(){const t=Object(i.useRef)(null),[e,a]=Object(i.useState)([]),[c,r]=Object(i.useState)([]),[h,m]=Object(i.useState)([]);Object(i.useEffect)(()=>{if(t.current){const e=t.current.getBoundingClientRect(),i=Array.from({length:d*s},(t,a)=>({id:a,targetX:a%s*(e.width/s),targetY:Math.floor(a/s)*(e.height/d)})),n=i.map((t,a)=>Object(o.a)(Object(o.a)({},t),{},{initialX:e.left-200+50*Math.random(),initialY:e.top+Math.random()*e.height,image:\"/img/puzzle/piece\".concat(a+1,\".png\"),width:e.width/s,height:e.height/d}));r(i),a(n)}},[]);return n.a.createElement(\"div\",{className:\"container\"},n.a.createElement(\"div\",{className:\"board-container\"},n.a.createElement(\"div\",{className:\"board\",ref:t},n.a.createElement(\"img\",{src:g,alt:\"Puzzle Board\",className:\"board-image\"})),e.map(t=>n.a.createElement(l.a.div,{key:t.id,className:\"piece\",style:{width:t.width,height:t.height,position:\"absolute\",cursor:\"grab\"},drag:!h.includes(t.id),dragElastic:.5,initial:{x:t.initialX,y:t.initialY},animate:{x:t.initialX,y:t.initialY},onDragEnd:(e,i)=>((t,e,i)=>{const n=c.find(t=>t.id===i.id);Math.abs(e.point.x-n.targetX)<i.width/3&&Math.abs(e.point.y-n.targetY)<i.height/3&&(m(t=>[...t,i.id]),a(t=>t.map(t=>t.id===i.id?Object(o.a)(Object(o.a)({},t),{},{initialX:n.targetX,initialY:n.targetY}):t)))})(0,i,t)},n.a.createElement(\"img\",{src:t.image,alt:\"piece-\".concat(t.id),style:{width:\"100%\",height:\"100%\",objectFit:\"contain\"}})))))}const m=document.getElementById(\"root\");r.a.render(n.a.createElement(n.a.StrictMode,null,n.a.createElement(h,null)),m)},6:function(t,e,a){t.exports=a(12)}},[[6,1,2]]]);","extractedComments":[]}