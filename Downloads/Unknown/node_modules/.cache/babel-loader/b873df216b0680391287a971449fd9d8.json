{"ast":null,"code":"import _objectSpread from \"/Users/godploy/Downloads/Unknown/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nvar _jsxFileName = \"/Users/godploy/Downloads/Unknown/src/App.js\";\n// import React from \"react\";\n// import { useState } from \"react\";\n// import { motion, AnimateSharedLayout } from \"framer-motion\";\n// import { useViewportWidth } from \"./use-viewport-width\";\n// import \"./styles.css\";\n\n// /**\n//  * NOTICE: This won't work in later versions of Framer Motion. The\n//  * shared drag gesture was never widely used. But we may add it back\n//  * some time in the future.\n//  *\n//  * This is an example of a shared drag gesture in Framer Motion 2.\n//  *\n//  * When the box is dragged from one half to the other, it gets\n//  * removed from one component and added in the other. This isn't\n//  * the same box - it is two seperate components that share a layoutId.\n//  */\n\n// export default function App() {\n//   const viewportWidth = useViewportWidth();\n//   const [activeHalf, setActiveHalf] = useState(\"a\");\n\n//   const [pieces, setPieces] = useState(createGrid());\n// const [completed, setCompleted] = useState([]);\n// const NUM_ROWS = 3; // จำนวนแถว\n// const NUM_COLS = 4; // จำนวนคอลัมน์\n// const createGrid = () =>\n//   Array.from({ length: NUM_ROWS * NUM_COLS }, (_, index) => ({\n//     id: index,\n//     x: (index % NUM_COLS) * 100, // คำนวณตำแหน่งแนวนอน\n//     y: Math.floor(index / NUM_COLS) * 100, // คำนวณตำแหน่งแนวตั้ง\n//   }));\n//   const handleDragEnd = (event, info, piece) => {\n//     const target = pieces.find((p) => p.id === piece.id);\n\n//     // ตรวจสอบว่าชิ้นอยู่ใกล้ตำแหน่งเป้าหมายหรือไม่\n//     if (\n//       Math.abs(info.point.x - target.x) < 50 &&\n//       Math.abs(info.point.y - target.y) < 50\n//     ) {\n//       setCompleted((prev) => [...prev, piece.id]); // เพิ่ม ID ที่เสร็จแล้วใน completed\n//     } else {\n//       // ถ้าไม่ถูก ให้คืนชิ้นไปตำแหน่งเดิม\n//       setPieces((prev) =>\n//         prev.map((p) => (p.id === piece.id ? { ...p } : p))\n//       );\n//     }\n//   };\n\n//   const onViewportBoxUpdate = ({ x }) => {\n//     const halfViewport = viewportWidth.current / 2;\n\n//     if (activeHalf === \"a\" && x.min > halfViewport) {\n//       setActiveHalf(\"b\");\n//     } else if (activeHalf === \"b\" && x.max < halfViewport) {\n//       setActiveHalf(\"a\");\n//     }\n//   };\n\n//   return (\n//     <AnimateSharedLayout>\n//       <div className=\"container\">\n//         <Zone\n//           color=\"#f107a3\"\n//           isSelected={activeHalf === \"a\"}\n//           onViewportBoxUpdate={onViewportBoxUpdate}\n//         />\n//         <Zone\n//           color=\"#7b2ff7\"\n//           isSelected={activeHalf === \"b\"}\n//           onViewportBoxUpdate={onViewportBoxUpdate}\n//         />\n//       </div>\n//     </AnimateSharedLayout>\n//   );\n// }\n\n// function Zone({ color, isSelected, onViewportBoxUpdate }) {\n//   return (\n//     <div className=\"half-container\">\n//       {/* <motion.div className=\"overlay\" />\n//       {isSelected && (\n//         <motion.div\n//           className=\"box\"\n//           layoutId=\"box\"\n//           initial={false}\n//           animate={{ backgroundColor: color }}\n//           drag\n//           // Snap the box back to its center when we let go\n//           dragConstraints={{ top: 0, left: 0, right: 0, bottom: 0 }}\n//           // Allow full movememnt outside constraints\n//           dragElastic={1}\n//           onViewportBoxUpdate={onViewportBoxUpdate}\n//         /> */}\n//         {pieces.map(\n//   (piece) =>\n//     !completed.includes(piece.id) && (\n//       <motion.div\n//         key={piece.id}\n//         className=\"piece\"\n//         style={{\n//           backgroundImage: \"url('/path-to-your-puzzle-image.jpg')\",\n//           backgroundSize: `${NUM_COLS * 100}px ${NUM_ROWS * 100}px`, // ขนาดภาพเต็ม\n//           backgroundPosition: `-${piece.x}px -${piece.y}px`, // ตำแหน่งของชิ้น\n//         }}\n//         drag\n//         dragElastic={0.5}\n//         initial={{ x: piece.x, y: piece.y }}\n//         onDragEnd={(event, info) => handleDragEnd(event, info, piece)}\n//       >\n//         {/* ไม่ต้องมีข้อความ */}\n//       </motion.div>\n//     )\n\n//       )}\n//     </div>\n//   );\n// }\n\nconst NUM_ROWS = 3;\nconst NUM_COLS = 4;\n\n// สร้างข้อมูล Grid พร้อมลิงก์ภาพแต่ละชิ้น\nconst createGrid = () => Array.from({\n  length: NUM_ROWS * NUM_COLS\n}, (_, index) => ({\n  id: index,\n  x: index % NUM_COLS * 100,\n  y: Math.floor(index / NUM_COLS) * 100,\n  image: \"/puzzle/puzzle\".concat(index + 1, \".svg\") // ลิงก์ไปยังภาพแต่ละชิ้น\n}));\nexport default function App() {\n  const [pieces, setPieces] = useState(createGrid());\n  const [completed, setCompleted] = useState([]);\n  const handleDragEnd = (event, info, piece) => {\n    const target = pieces.find(p => p.id === piece.id);\n    if (Math.abs(info.point.x - target.x) < 50 && Math.abs(info.point.y - target.y) < 50) {\n      setCompleted(prev => [...prev, piece.id]);\n    } else {\n      setPieces(prev => prev.map(p => p.id === piece.id ? _objectSpread({}, p) : p));\n    }\n  };\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"board\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 156,\n      columnNumber: 5\n    }\n  }, pieces.map(piece => /*#__PURE__*/React.createElement(\"div\", {\n    key: piece.id,\n    className: \"target\",\n    style: {\n      left: piece.x,\n      top: piece.y\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 159,\n      columnNumber: 9\n    }\n  })), pieces.map(piece => !completed.includes(piece.id) && /*#__PURE__*/React.createElement(motion.div, {\n    key: piece.id,\n    className: \"piece\",\n    style: {\n      backgroundImage: \"url(\".concat(piece.image, \")\"),\n      // ใช้ภาพจาก `image`\n      backgroundSize: \"100px 100px\",\n      // ขนาดชิ้น\n      width: \"100px\",\n      height: \"100px\"\n    },\n    drag: true,\n    dragElastic: 0.5,\n    initial: {\n      x: piece.x,\n      y: piece.y\n    },\n    onDragEnd: (event, info) => handleDragEnd(event, info, piece),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 173,\n      columnNumber: 13\n    }\n  })));\n}","map":{"version":3,"names":["NUM_ROWS","NUM_COLS","createGrid","Array","from","length","_","index","id","x","y","Math","floor","image","concat","App","pieces","setPieces","useState","completed","setCompleted","handleDragEnd","event","info","piece","target","find","p","abs","point","prev","map","_objectSpread","React","createElement","className","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","key","style","left","top","includes","motion","div","backgroundImage","backgroundSize","width","height","drag","dragElastic","initial","onDragEnd"],"sources":["/Users/godploy/Downloads/Unknown/src/App.js"],"sourcesContent":["// import React from \"react\";\n// import { useState } from \"react\";\n// import { motion, AnimateSharedLayout } from \"framer-motion\";\n// import { useViewportWidth } from \"./use-viewport-width\";\n// import \"./styles.css\";\n\n// /**\n//  * NOTICE: This won't work in later versions of Framer Motion. The\n//  * shared drag gesture was never widely used. But we may add it back\n//  * some time in the future.\n//  *\n//  * This is an example of a shared drag gesture in Framer Motion 2.\n//  *\n//  * When the box is dragged from one half to the other, it gets\n//  * removed from one component and added in the other. This isn't\n//  * the same box - it is two seperate components that share a layoutId.\n//  */\n\n// export default function App() {\n//   const viewportWidth = useViewportWidth();\n//   const [activeHalf, setActiveHalf] = useState(\"a\");\n\n//   const [pieces, setPieces] = useState(createGrid());\n// const [completed, setCompleted] = useState([]);\n// const NUM_ROWS = 3; // จำนวนแถว\n// const NUM_COLS = 4; // จำนวนคอลัมน์\n// const createGrid = () =>\n//   Array.from({ length: NUM_ROWS * NUM_COLS }, (_, index) => ({\n//     id: index,\n//     x: (index % NUM_COLS) * 100, // คำนวณตำแหน่งแนวนอน\n//     y: Math.floor(index / NUM_COLS) * 100, // คำนวณตำแหน่งแนวตั้ง\n//   }));\n//   const handleDragEnd = (event, info, piece) => {\n//     const target = pieces.find((p) => p.id === piece.id);\n  \n//     // ตรวจสอบว่าชิ้นอยู่ใกล้ตำแหน่งเป้าหมายหรือไม่\n//     if (\n//       Math.abs(info.point.x - target.x) < 50 &&\n//       Math.abs(info.point.y - target.y) < 50\n//     ) {\n//       setCompleted((prev) => [...prev, piece.id]); // เพิ่ม ID ที่เสร็จแล้วใน completed\n//     } else {\n//       // ถ้าไม่ถูก ให้คืนชิ้นไปตำแหน่งเดิม\n//       setPieces((prev) =>\n//         prev.map((p) => (p.id === piece.id ? { ...p } : p))\n//       );\n//     }\n//   };\n  \n\n\n\n//   const onViewportBoxUpdate = ({ x }) => {\n//     const halfViewport = viewportWidth.current / 2;\n\n//     if (activeHalf === \"a\" && x.min > halfViewport) {\n//       setActiveHalf(\"b\");\n//     } else if (activeHalf === \"b\" && x.max < halfViewport) {\n//       setActiveHalf(\"a\");\n//     }\n//   };\n\n//   return (\n//     <AnimateSharedLayout>\n//       <div className=\"container\">\n//         <Zone\n//           color=\"#f107a3\"\n//           isSelected={activeHalf === \"a\"}\n//           onViewportBoxUpdate={onViewportBoxUpdate}\n//         />\n//         <Zone\n//           color=\"#7b2ff7\"\n//           isSelected={activeHalf === \"b\"}\n//           onViewportBoxUpdate={onViewportBoxUpdate}\n//         />\n//       </div>\n//     </AnimateSharedLayout>\n//   );\n// }\n\n// function Zone({ color, isSelected, onViewportBoxUpdate }) {\n//   return (\n//     <div className=\"half-container\">\n//       {/* <motion.div className=\"overlay\" />\n//       {isSelected && (\n//         <motion.div\n//           className=\"box\"\n//           layoutId=\"box\"\n//           initial={false}\n//           animate={{ backgroundColor: color }}\n//           drag\n//           // Snap the box back to its center when we let go\n//           dragConstraints={{ top: 0, left: 0, right: 0, bottom: 0 }}\n//           // Allow full movememnt outside constraints\n//           dragElastic={1}\n//           onViewportBoxUpdate={onViewportBoxUpdate}\n//         /> */}\n//         {pieces.map(\n//   (piece) =>\n//     !completed.includes(piece.id) && (\n//       <motion.div\n//         key={piece.id}\n//         className=\"piece\"\n//         style={{\n//           backgroundImage: \"url('/path-to-your-puzzle-image.jpg')\",\n//           backgroundSize: `${NUM_COLS * 100}px ${NUM_ROWS * 100}px`, // ขนาดภาพเต็ม\n//           backgroundPosition: `-${piece.x}px -${piece.y}px`, // ตำแหน่งของชิ้น\n//         }}\n//         drag\n//         dragElastic={0.5}\n//         initial={{ x: piece.x, y: piece.y }}\n//         onDragEnd={(event, info) => handleDragEnd(event, info, piece)}\n//       >\n//         {/* ไม่ต้องมีข้อความ */}\n//       </motion.div>\n//     )\n\n//       )}\n//     </div>\n//   );\n// }\n\n\nconst NUM_ROWS = 3;\nconst NUM_COLS = 4;\n\n// สร้างข้อมูล Grid พร้อมลิงก์ภาพแต่ละชิ้น\nconst createGrid = () =>\n  Array.from({ length: NUM_ROWS * NUM_COLS }, (_, index) => ({\n    id: index,\n    x: (index % NUM_COLS) * 100,\n    y: Math.floor(index / NUM_COLS) * 100,\n    image: `/puzzle/puzzle${index + 1}.svg`, // ลิงก์ไปยังภาพแต่ละชิ้น\n  }));\n\nexport default function App() {\n  const [pieces, setPieces] = useState(createGrid());\n  const [completed, setCompleted] = useState([]);\n\n  const handleDragEnd = (event, info, piece) => {\n    const target = pieces.find((p) => p.id === piece.id);\n\n    if (\n      Math.abs(info.point.x - target.x) < 50 &&\n      Math.abs(info.point.y - target.y) < 50\n    ) {\n      setCompleted((prev) => [...prev, piece.id]);\n    } else {\n      setPieces((prev) =>\n        prev.map((p) => (p.id === piece.id ? { ...p } : p))\n      );\n    }\n  };\n\n  return (\n    <div className=\"board\">\n      {/* กระดานเป้าหมาย */}\n      {pieces.map((piece) => (\n        <div\n          key={piece.id}\n          className=\"target\"\n          style={{\n            left: piece.x,\n            top: piece.y,\n          }}\n        />\n      ))}\n\n      {/* ชิ้นจิ๊กซอว์ */}\n      {pieces.map(\n        (piece) =>\n          !completed.includes(piece.id) && (\n            <motion.div\n              key={piece.id}\n              className=\"piece\"\n              style={{\n                backgroundImage: `url(${piece.image})`, // ใช้ภาพจาก `image`\n                backgroundSize: \"100px 100px\", // ขนาดชิ้น\n                width: \"100px\",\n                height: \"100px\",\n              }}\n              drag\n              dragElastic={0.5}\n              initial={{ x: piece.x, y: piece.y }}\n              onDragEnd={(event, info) => handleDragEnd(event, info, piece)}\n            />\n          )\n      )}\n    </div>\n  );\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}