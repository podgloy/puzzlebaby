{"map":"{\"version\":3,\"sources\":[\"/Users/godploy/Downloads/Unknown/src/App.js\",\"/Users/godploy/Downloads/Unknown/src/index.js\"],\"names\":[\"NUM_ROWS\",\"NUM_COLS\",\"boardImage\",\"App\",\"boardRef\",\"useRef\",\"pieces\",\"setPieces\",\"useState\",\"targets\",\"setTargets\",\"completed\",\"setCompleted\",\"useEffect\",\"current\",\"rect\",\"getBoundingClientRect\",\"newTargets\",\"Array\",\"from\",\"length\",\"_\",\"index\",\"id\",\"targetX\",\"left\",\"width\",\"targetY\",\"top\",\"Math\",\"floor\",\"height\",\"newPieces\",\"map\",\"target\",\"_objectSpread\",\"initialX\",\"initialY\",\"random\",\"image\",\"concat\",\"React\",\"createElement\",\"className\",\"ref\",\"style\",\"backgroundImage\",\"backgroundSize\",\"backgroundPosition\",\"backgroundRepeat\",\"piece\",\"motion\",\"div\",\"key\",\"position\",\"cursor\",\"drag\",\"includes\",\"dragElastic\",\"initial\",\"x\",\"y\",\"animate\",\"onPointerDown\",\"event\",\"preventDefault\",\"onDragStart\",\"onDragEnd\",\"info\",\"handleDragEnd\",\"find\",\"t\",\"abs\",\"point\",\"prev\",\"p\",\"src\",\"alt\",\"objectFit\",\"rootElement\",\"document\",\"getElementById\",\"ReactDOM\",\"render\",\"StrictMode\"],\"mappings\":\"6KAyGA,MAAMA,EAAW,EACXC,EAAW,EACXC,EAAa,uBAEJ,SAASC,IACtB,MAAMC,EAAWC,OAAAA,EAAAA,OAAAA,CAAO,OACjBC,EAAQC,GAAaC,OAAAA,EAAAA,SAAAA,CAAS,KAC9BC,EAASC,GAAcF,OAAAA,EAAAA,SAAAA,CAAS,KAChCG,EAAWC,GAAgBJ,OAAAA,EAAAA,SAAAA,CAAS,IAE3CK,OAAAA,EAAAA,UAAAA,CAAU,KACR,GAAIT,EAASU,QAAS,CACpB,MAAMC,EAAOX,EAASU,QAAQE,wBAExBC,EAAaC,MAAMC,KAAK,CAAEC,OAAQpB,EAAWC,GAAY,CAACoB,EAAGC,KAAK,CACtEC,GAAID,EACJE,QAAST,EAAKU,KAAQH,EAAQrB,GAAac,EAAKW,MAAQzB,GACxD0B,QAASZ,EAAKa,IAAMC,KAAKC,MAAMR,EAAQrB,IAAac,EAAKgB,OAAS/B,MAG9DgC,EAAYf,EAAWgB,IAAI,CAACC,EAAQZ,IAAKa,OAAAA,EAAAA,EAAAA,CAAAA,OAAAA,EAAAA,EAAAA,CAAA,GAC1CD,GAAM,GAAA,CACTE,SAAUrB,EAAKU,KAAO,IAAOH,EAAQrB,EAAY,GACjDoC,SAAUtB,EAAKa,IAAMC,KAAKS,SAAWvB,EAAKgB,OAC1CQ,MAAK,oBAAAC,OAAsBN,EAAOX,GAAK,EAAC,QACxCG,MAAOX,EAAKW,MAAQzB,EACpB8B,OAAQhB,EAAKgB,OAAS/B,KAGxBU,EAAWO,GACXV,EAAUyB,KAEX,IAgBH,OACES,EAAAA,EAAAC,cAAA,MAAA,CAAKC,UAAU,mBACbF,EAAAA,EAAAC,cAAA,MAAA,CACEC,UAAU,QACVC,IAAKxC,EACLyC,MAAO,CACLC,gBAAe,OAAAN,OAAStC,EAAU,KAClC6C,eAAgB,UAChBC,mBAAoB,SACpBC,iBAAkB,eAIrB3C,EAAO2B,IAAKiB,GACXT,EAAAA,EAAAC,cAACS,EAAAA,EAAOC,IAAG,CACTC,IAAKH,EAAM3B,GACXoB,UAAU,QACVE,MAAO,CACLS,SAAU,WACVC,OAAQ,OACR7B,MAAOwB,EAAMxB,MACbK,OAAQmB,EAAMnB,QAEhByB,MAAO7C,EAAU8C,SAASP,EAAM3B,IAChCmC,YAAa,GACbC,QAAS,CAAEC,EAAGV,EAAMd,SAAUyB,EAAGX,EAAMb,UACvCyB,QAAS,CAAEF,EAAGV,EAAMd,SAAUyB,EAAGX,EAAMb,UACvC0B,cAAgBC,GAAUA,EAAMC,iBAChCC,YAAcF,GAAUA,EAAMC,iBAC9BE,UAAWA,CAACH,EAAOI,IA3CLC,EAACL,EAAOI,EAAMlB,KAClC,MAAMhB,EAASzB,EAAQ6D,KAAMC,GAAMA,EAAEhD,KAAO2B,EAAM3B,IAGhDM,KAAK2C,IAAIJ,EAAKK,MAAMb,EAAI1B,EAAOV,SAAW0B,EAAMxB,MAAQ,GACxDG,KAAK2C,IAAIJ,EAAKK,MAAMZ,EAAI3B,EAAOP,SAAWuB,EAAMnB,OAAS,IAEzDnB,EAAc8D,GAAS,IAAIA,EAAMxB,EAAM3B,KACvChB,EAAWmE,GACTA,EAAKzC,IAAK0C,GAAOA,EAAEpD,KAAO2B,EAAM3B,GAAEY,OAAAA,EAAAA,EAAAA,CAAAA,OAAAA,EAAAA,EAAAA,CAAA,GAAQwC,GAAC,GAAA,CAAEvC,SAAUF,EAAOV,QAASa,SAAUH,EAAOP,UAAYgD,MAkCtEN,CAAcL,EAAOI,EAAMlB,IAEvDT,EAAAA,EAAAC,cAAA,MAAA,CACEkC,IAAK1B,EAAMX,MACXsC,IAAG,SAAArC,OAAWU,EAAM3B,IACpBsB,MAAO,CACLnB,MAAO,OACPK,OAAQ,OACR+C,UAAW,gBCzLzB,MAAMC,EAAcC,SAASC,eAAe,QAC5CC,EAAAA,EAASC,OACP1C,EAAAA,EAAAC,cAACD,EAAAA,EAAM2C,WAAU,KACf3C,EAAAA,EAAAC,cAACvC,EAAG,OAEN4E\",\"sourcesContent\":[\"// import React, { useState } from \\\"react\\\";\\n// import { motion } from \\\"framer-motion\\\";\\n// import \\\"./styles.css\\\";\\n\\n// const NUM_ROWS = 4;\\n// const NUM_COLS = 3;\\n// const PIECE_SIZE = 80; // ขนาดชิ้นจิ๊กซอว์ที่เล็กลง\\n\\n// const OFFSET_X = 200; // ขยับตำแหน่งแนวนอน\\n// const OFFSET_Y = 100; // ขยับตำแหน่งแนวตั้ง\\n\\n// const createGrid = () =>\\n//   Array.from({ length: NUM_ROWS * NUM_COLS }, (_, index) => ({\\n//     id: index,\\n//     targetX: (index % NUM_COLS) * 100 + OFFSET_X, // 🔥 ขยับกรอบเป้าหมาย\\n//     targetY: Math.floor(index / NUM_COLS) * 100 + OFFSET_Y, // 🔥 ขยับกรอบเป้าหมาย\\n//     initialX: 500 + Math.random() * 50, // 🔥 จุดเริ่มต้นของจิ๊กซอว์\\n//     initialY: 300 + Math.random() * 50,\\n//     image: `/img/puzzle/piece${index + 1}.png`, \\n//   }));\\n\\n\\n// export default function App() {\\n//   const [pieces, setPieces] = useState(createGrid());\\n\\n//   const handleDragEnd = (event, info, piece) => {\\n//     const target = pieces.find((p) => p.id === piece.id);\\n\\n//     console.log(`🟢 Piece ${piece.id} Dragged to:`, {\\n//       draggedX: info.point.x,\\n//       draggedY: info.point.y,\\n//       targetX: target.targetX,\\n//       targetY: target.targetY,\\n//     });\\n\\n//     if (\\n//       Math.abs(info.point.x - target.targetX) < PIECE_SIZE * 0.75 &&\\n//       Math.abs(info.point.y - target.targetY) < PIECE_SIZE * 0.75\\n//     )\\n//      {\\n//       setPieces((prev) =>\\n//         prev.map((p) =>\\n//           p.id === piece.id\\n//             ? { ...p, initialX: target.targetX, initialY: target.targetY, locked: true }\\n//             : p\\n//         )\\n//       );\\n//     }\\n//   };\\n\\n//   return (\\n//     <div className=\\\"board\\\" style={{ position: \\\"relative\\\", width: \\\"100vw\\\", height: \\\"100vh\\\" }}>\\n//       {/* กรอบเป้าหมาย */}\\n//       {pieces.map((piece) => (\\n//         <div\\n//           key={`target-${piece.id}`}\\n//           className=\\\"target\\\"\\n//           style={{\\n//             left: piece.targetX,\\n//             top: piece.targetY,\\n//             width: PIECE_SIZE,\\n//             height: PIECE_SIZE,\\n//             position: \\\"absolute\\\",\\n//             border: \\\"2px dashed #ccc\\\",\\n//           }}\\n//         />\\n//       ))}\\n\\n//       {/* ชิ้นจิ๊กซอว์ */}\\n//       {pieces.map((piece) => (\\n//         <motion.div\\n//           key={`piece-${piece.id}`}\\n//           className=\\\"piece\\\"\\n//           style={{\\n//             position: \\\"absolute\\\",\\n//             cursor: piece.locked ? \\\"default\\\" : \\\"grab\\\",\\n//           }}\\n//           drag={!piece.locked} // ✅ ล็อคชิ้นส่วนถ้าลากไปวางแล้ว\\n//           dragElastic={0.5}\\n//           initial={{ x: piece.initialX, y: piece.initialY }}\\n//           animate={{ x: piece.initialX, y: piece.initialY }} // ✅ ใช้ค่าที่อัปเดตล่าสุด\\n//           onPointerDown={(event) => event.preventDefault()} // ป้องกัน Safari ลากรูปออก\\n//           onDragStart={(event) => event.preventDefault()} // ป้องกันการดึงรูปออกจากเว็บ\\n//           onDragEnd={(event, info) => handleDragEnd(event, info, piece)}\\n//         >\\n//           <img\\n//             src={piece.image}\\n//             alt={`piece-${piece.id}`}\\n//             style={{\\n//               width: `${PIECE_SIZE}px`, // ✅ กำหนดขนาดเป็นสัดส่วน\\n//               height: `${PIECE_SIZE}px`,\\n//               objectFit: \\\"contain\\\",\\n//             }}\\n//           />\\n//         </motion.div>\\n//       ))}\\n//     </div>\\n//   );\\n// }\\n\\n\\nimport React, { useState, useEffect, useRef } from \\\"react\\\";\\nimport { motion } from \\\"framer-motion\\\";\\nimport \\\"./styles.css\\\";\\n\\nconst NUM_ROWS = 4;\\nconst NUM_COLS = 3;\\nconst boardImage = \\\"/img/puzzleboard.png\\\"; // ✅ ใส่ path ของกระดาน\\n\\nexport default function App() {\\n  const boardRef = useRef(null);\\n  const [pieces, setPieces] = useState([]);\\n  const [targets, setTargets] = useState([]);\\n  const [completed, setCompleted] = useState([]);\\n\\n  useEffect(() => {\\n    if (boardRef.current) {\\n      const rect = boardRef.current.getBoundingClientRect();\\n\\n      const newTargets = Array.from({ length: NUM_ROWS * NUM_COLS }, (_, index) => ({\\n        id: index,\\n        targetX: rect.left + (index % NUM_COLS) * (rect.width / NUM_COLS),\\n        targetY: rect.top + Math.floor(index / NUM_COLS) * (rect.height / NUM_ROWS),\\n      }));\\n\\n      const newPieces = newTargets.map((target, index) => ({\\n        ...target,\\n        initialX: rect.left - 250 + (index % NUM_COLS) * 50, // ✅ กระจายชิ้นส่วนด้านซ้าย\\n        initialY: rect.top + Math.random() * rect.height,\\n        image: `/img/puzzle/piece${target.id + 1}.png`, // ✅ รูปจิ๊กซอว์แต่ละชิ้น\\n        width: rect.width / NUM_COLS,\\n        height: rect.height / NUM_ROWS,\\n      }));\\n\\n      setTargets(newTargets);\\n      setPieces(newPieces);\\n    }\\n  }, []);\\n\\n  const handleDragEnd = (event, info, piece) => {\\n    const target = targets.find((t) => t.id === piece.id);\\n\\n    if (\\n      Math.abs(info.point.x - target.targetX) < piece.width / 2 &&\\n      Math.abs(info.point.y - target.targetY) < piece.height / 2\\n    ) {\\n      setCompleted((prev) => [...prev, piece.id]);\\n      setPieces((prev) =>\\n        prev.map((p) => (p.id === piece.id ? { ...p, initialX: target.targetX, initialY: target.targetY } : p))\\n      );\\n    }\\n  };\\n\\n  return (\\n    <div className=\\\"board-container\\\">\\n      <div\\n        className=\\\"board\\\"\\n        ref={boardRef}\\n        style={{\\n          backgroundImage: `url(${boardImage})`,\\n          backgroundSize: \\\"contain\\\",\\n          backgroundPosition: \\\"center\\\",\\n          backgroundRepeat: \\\"no-repeat\\\",\\n        }}\\n      />\\n\\n      {pieces.map((piece) => (\\n        <motion.div\\n          key={piece.id}\\n          className=\\\"piece\\\"\\n          style={{\\n            position: \\\"absolute\\\",\\n            cursor: \\\"grab\\\",\\n            width: piece.width,\\n            height: piece.height,\\n          }}\\n          drag={!completed.includes(piece.id)}\\n          dragElastic={0.5}\\n          initial={{ x: piece.initialX, y: piece.initialY }}\\n          animate={{ x: piece.initialX, y: piece.initialY }}\\n          onPointerDown={(event) => event.preventDefault()}\\n          onDragStart={(event) => event.preventDefault()}\\n          onDragEnd={(event, info) => handleDragEnd(event, info, piece)}\\n        >\\n          <img\\n            src={piece.image}\\n            alt={`piece-${piece.id}`}\\n            style={{\\n              width: \\\"100%\\\",\\n              height: \\\"100%\\\",\\n              objectFit: \\\"contain\\\",\\n            }}\\n          />\\n        </motion.div>\\n      ))}\\n    </div>\\n  );\\n}\\n\",\"import React from \\\"react\\\";\\nimport ReactDOM from \\\"react-dom\\\";\\n\\nimport App from \\\"./App\\\";\\n\\nconst rootElement = document.getElementById(\\\"root\\\");\\nReactDOM.render(\\n  <React.StrictMode>\\n    <App />\\n  </React.StrictMode>,\\n  rootElement\\n);\\n\"]}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{11:function(t,e,i){},12:function(t,e,i){\"use strict\";i.r(e);var a=i(0),n=i.n(a),c=i(4),r=i.n(c),o=i(1),l=i(5);i(11);const d=4,g=3,s=\"/img/puzzleboard.png\";function u(){const t=Object(a.useRef)(null),[e,i]=Object(a.useState)([]),[c,r]=Object(a.useState)([]),[u,h]=Object(a.useState)([]);Object(a.useEffect)(()=>{if(t.current){const e=t.current.getBoundingClientRect(),a=Array.from({length:d*g},(t,i)=>({id:i,targetX:e.left+i%g*(e.width/g),targetY:e.top+Math.floor(i/g)*(e.height/d)})),n=a.map((t,i)=>Object(o.a)(Object(o.a)({},t),{},{initialX:e.left-250+i%g*50,initialY:e.top+Math.random()*e.height,image:\"/img/puzzle/piece\".concat(t.id+1,\".png\"),width:e.width/g,height:e.height/d}));r(a),i(n)}},[]);return n.a.createElement(\"div\",{className:\"board-container\"},n.a.createElement(\"div\",{className:\"board\",ref:t,style:{backgroundImage:\"url(\".concat(s,\")\"),backgroundSize:\"contain\",backgroundPosition:\"center\",backgroundRepeat:\"no-repeat\"}}),e.map(t=>n.a.createElement(l.a.div,{key:t.id,className:\"piece\",style:{position:\"absolute\",cursor:\"grab\",width:t.width,height:t.height},drag:!u.includes(t.id),dragElastic:.5,initial:{x:t.initialX,y:t.initialY},animate:{x:t.initialX,y:t.initialY},onPointerDown:t=>t.preventDefault(),onDragStart:t=>t.preventDefault(),onDragEnd:(e,a)=>((t,e,a)=>{const n=c.find(t=>t.id===a.id);Math.abs(e.point.x-n.targetX)<a.width/2&&Math.abs(e.point.y-n.targetY)<a.height/2&&(h(t=>[...t,a.id]),i(t=>t.map(t=>t.id===a.id?Object(o.a)(Object(o.a)({},t),{},{initialX:n.targetX,initialY:n.targetY}):t)))})(0,a,t)},n.a.createElement(\"img\",{src:t.image,alt:\"piece-\".concat(t.id),style:{width:\"100%\",height:\"100%\",objectFit:\"contain\"}}))))}const h=document.getElementById(\"root\");r.a.render(n.a.createElement(n.a.StrictMode,null,n.a.createElement(u,null)),h)},6:function(t,e,i){t.exports=i(12)}},[[6,1,2]]]);","extractedComments":[]}